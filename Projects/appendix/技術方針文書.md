# HandEst プロジェクト技術方針文書

## 1. 概要

本文書は、HandEstプロジェクトの技術的な方針と実装戦略を定義します。MVPの早期リリースを目指した現実的なアプローチを採用し、段階的な品質向上を図ります。

## 2. 技術スタック

### 2.1 確定済み技術選択

#### アーキテクチャ・UI層
- **SwiftUI**: 宣言的UIフレームワーク
- **The Composable Architecture (TCA)**: 状態管理とビジネスロジック
- **対応OS**: iOS 18.2以上

#### 3Dレンダリング
- **RealityKit**: Metal最適化された3Dレンダリングエンジン
- **ModelEntity**: スキンメッシュアニメーション対応
- **.usdz/.reality**: 3Dモデル形式

#### 手認識・カメラ
- **MediaPipe Hands**: 21関節点の高精度手認識
- **AVFoundation**: 低レベルカメラアクセス

### 2.2 選定理由

#### TCA採用理由
- 単一方向データフロー（Flux pattern）による予測可能な状態管理
- 優れたテスタビリティ（TestStore）
- 大規模アプリケーションでの実績
- 依存関係の明確な分離

#### MediaPipe採用理由
- x, y, z座標の3次元データ取得可能
- 21個の関節点を高精度で認識（平均誤差約10mm）
- リアルタイム処理に最適化（30fps対応）
- iOSネイティブサポート

#### RealityKit採用理由
- Metal最適化による高速レンダリング
- スキンメッシュアニメーションの標準サポート
- カメラ投影方式の柔軟な制御
- Appleエコシステムとの親和性

## 3. アーキテクチャ設計

### 3.1 レイヤード構成

```
UI層（SwiftUI）
├── Features/（機能モジュール）
│   ├── Camera/         - カメラ制御
│   ├── HandTracking/   - 手認識処理
│   ├── Rendering/      - 3Dレンダリング
│   └── Settings/       - 設定管理
├── Models/（共有データモデル）
├── Shared/（共有コンポーネント）
└── Resources/（アセット・ローカライゼーション）
```

### 3.2 TCAによる状態管理

#### 基本原則
1. **単一方向データフロー**: View → Action → Reducer → State → View
2. **Immutableな状態**: StateはReducerでのみ変更
3. **副作用の明示**: EffectとしてAPIコール、非同期処理を管理
4. **テスタビリティ**: 依存関係の注入とモック化

#### Feature分割戦略
```swift
struct AppFeature: Reducer {
    struct State {
        var camera: CameraFeature.State = CameraFeature.State()
        var handTracking: HandTrackingFeature.State = HandTrackingFeature.State()
        var rendering: RenderingFeature.State = RenderingFeature.State()
        var settings: SettingsFeature.State = SettingsFeature.State()
    }
    
    enum Action {
        case camera(CameraFeature.Action)
        case handTracking(HandTrackingFeature.Action)
        case rendering(RenderingFeature.Action)
        case settings(SettingsFeature.Action)
    }
}
```

### 3.3 データフロー

1. **カメラ入力**: AVCaptureSession → CVPixelBuffer
2. **手認識**: MediaPipe → HandLandmark[]
3. **3D変換**: 関節点 → 3Dモデル座標
4. **レンダリング**: RealityKit → 画面表示

## 4. 開発アプローチ

### 4.1 型定義駆動TDD

#### 開発フロー
1. **型定義**: TCAのState/Action/Environmentを定義
2. **テスト設計**: Reducerのテストケースを作成
3. **実装**: テストが通るように実装
4. **リファクタリング**: 型とテストを維持しながら改善

#### テスト戦略
- **単体テスト**: TCAのTestStoreによる状態遷移テスト
- **統合テスト**: Feature間の連携テスト
- **UIテスト**: 重要なユーザーフローのE2Eテスト

### 4.2 品質管理

#### 自動化ツール
- **SwiftLint**: コード品質チェック（project.ymlで設定済み）
- **Git Hooks**: コミット前の自動テスト実行
- **並列実行**: テスト高速化（parallelizeTargets設定済み）

#### コーディング規約
- SwiftUIとTCAのベストプラクティスに準拠
- 日本語コメント・ドキュメント
- 型安全性の最大化

## 5. パフォーマンス目標

### 5.1 性能要件
- **フレームレート**: 30fps以上でのリアルタイム表示
- **認識精度**: 良好な照明条件下で95%以上の成功率
- **応答性**: ユーザー操作に対して100ms以下の遅延
- **バッテリー**: 15-20分使用で10-15%消費以下

### 5.2 最適化戦略
- **Metal最適化**: RealityKitの活用
- **並列処理**: MediaPipe推論とレンダリングの並列化
- **メモリ管理**: 適切なオブジェクトライフサイクル管理
- **サーマル対策**: 発熱時の自動品質低下

## 6. セキュリティ・プライバシー

### 6.1 データ保護
- **ローカル処理**: カメラ映像をサーバーに送信しない
- **一時データ**: 処理用データの適切な破棄
- **権限管理**: 最小限必要な権限のみ要求

### 6.2 App Store準拠
- **Privacy Nutrition**: 正確なプライバシーラベル
- **カメラ使用説明**: 明確な用途説明
- **4+レーティング**: 誰でも利用可能な設計

## 7. 開発体制・スケジュール

### 7.1 必要スキルセット
- **iOS開発**: SwiftUI + TCA経験
- **3D技術**: RealityKit + 3Dモデリング知識
- **ML統合**: MediaPipe iOS統合経験

### 7.2 リスク軽減
- **プロトタイプ優先**: 技術検証を先行実施
- **段階的リリース**: MVP → 改良版 → 完成版
- **代替技術準備**: Vision Framework等のフォールバック案

## 8. 次のステップ

1. **プロジェクトセットアップ**: 基本アーキテクチャの実装
2. **MediaPipe統合検証**: POCの作成と動作確認
3. **MVP開発**: 関節球による簡易3D表示
4. **段階的改良**: メッシュモデル → リアルスキンメッシュ

---

*文書作成日: 2025-05-28*
*最終更新日: 2025-05-28*